<!DOCTYPE html>
<html>
<head>
    <title>Interactive Game World Map</title>

    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            height: 100vh; /* Add fixed height */
            background-color: #f8fafc;
            font-family: Arial, sans-serif;
            box-sizing: border-box; /* Include padding in height calculation */
            overflow-y: hidden; /* Prevent body scroll */
        }
        .container {
            display: flex;
            gap: 20px;
            max-width: 100vw;
            width: 100%;
            height: calc(100vh - 40px); /* Account for body padding */
            overflow: hidden;
        }

        
        .map-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            padding: 20px;
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            height: 100%;
            box-sizing: border-box;
        }

        #canvas {
            max-height: 20px;
        }
        .info-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            padding: 20px;
            width: 300px;
            min-width: 300px;
            display: none;
        }
        .card-title {
            margin-bottom: 20px;
        }

        .controls {
            margin-bottom: 20px;
            flex-shrink: 0; /* Prevent controls from shrinking */
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .control-group label {
            white-space: nowrap;
        }
        
        #map-container {
            overflow: auto;
            flex: 1; /* Fill remaining space */
            width: 100%;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            position: relative;
            box-sizing: border-box;
        }
        #map {
            min-width: 100%;
            min-height: 100%;
            width: max-content;
            height: max-content;
        }
        .resize-handle {
            cursor: nw-resize;
            fill: #64748b;
        }
        .selection-rect {
            fill: rgba(59, 130, 246, 0.1);
            stroke: #3b82f6;
            stroke-width: 1;
            pointer-events: none;
        }
        .info-section {
            margin-bottom: 20px;
        }
        .info-section h3 {
            margin: 0 0 10px 0;
            color: #1e293b;
        }
        .connection-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .connection-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid #e2e8f0;
        }
        .delete-btn {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
        }
        .delete-btn:hover {
            background: #dc2626;
        }
        button {
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
        }
        button:hover {
            background: #2563eb;
        }

        svg {
            cursor: grab;
        }
        svg:active {
            cursor: grabbing;
        }
        .area-circle {
            cursor: move;
            transition: fill 0.2s;
            fill: #64748b;
        }
        .area-circle:hover {
            fill: #cbd5e1;
        }
        .area-circle.selected {
            fill: #bfdbfe;
            stroke: #3b82f6;
        }
        .area-text {
            pointer-events: none;
            user-select: none;
        }
        .area-circle.has-overroom {
            fill: #86efac; /* Light green for areas with overroom */
        }
        
        .area-circle.modified-overroom {
            fill: #fef08a; /* Light yellow for modified overroom */
        }
        
        ..info-section {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
        }
        
        .info-section h3 {
            margin: -10px -10px 10px -10px;
            padding: 8px 10px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            border-radius: 4px 4px 0 0;
            font-size: 0.9em;
            color: #475569;
        }
        
        .field-group {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .field-group > div {
            flex: 1;
        }
        
        .info-section input[type="text"],
        .info-section input[type="number"] {
            width: 100%;
            padding: 4px;
            margin-bottom: 4px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .info-section label {
            display: block;
            margin-bottom: 4px;
            color: #475569;
            font-size: 0.8em;
            font-weight: 500;
        }
        
        .read-only {
            background-color: #f8fafc;
            cursor: not-allowed;
        }
    </style>
    
</head>
<body>
    <div class="container">
        <div class="map-card">
            <div class="card-title">Interactive Game World Map</div>
            <div class="controls">
                <div class="control-group">
                    <label>Load Map Data:</label>
                    <input type="file" id="dataInput" accept=".json" />
                </div>
                <div class="control-group">
                    <label>Load Layout:</label>
                    <input type="file" id="layoutInput" accept=".json" />
                </div>
                <button onclick="saveLayout()">Save Layout</button>
                <button onclick="addNewArea()">Add New Area</button>
                <button id="pngbutton" >svg to png</button>
                <canvas id="canvas"></canvas>
            </div>
            <div id="map-container">
                <svg id="map" viewBox="0 0 5000 5000" width="5000" height="5000">
                    <defs>
                        <marker 
                            id="arrowhead" 
                            markerWidth="10" 
                            markerHeight="7" 
                            refX="9" 
                            refY="3.5" 
                            orient="auto"
                        >
                            <polygon points="0 0, 10 3.5, 0 7" fill="#666" />
                        </marker>
                    </defs>
                    <g id="connections"></g>
                    <g id="areas"></g>
                    <rect id="selection-rect" class="selection-rect" style="display: none"/>
                </svg>
            </div>
        </div>
        <div id="info-panel" class="info-panel">
            <div class="card-title">Area Information</div>
            
            <div class="info-section">
                <h3>Basic Information</h3>
                <label for="area-name">Area Name:</label>
                <input type="text" id="area-name" />
                
                <label for="area-credits">Credits:</label>
                <input type="text" id="area-credits" />
            </div>
            
            <div class="info-section">
                <h3>Level Range</h3>
                <div class="field-group">
                    <div>
                        <label for="min-level">Minimum Level:</label>
                        <input type="number" id="min-level" min="0" />
                    </div>
                    <div>
                        <label for="max-level">Maximum Level:</label>
                        <input type="number" id="max-level" min="0" />
                    </div>
                </div>
            </div>
            
            <div class="info-section">
                <h3>VNUM Range</h3>
                <div class="field-group">
                    <div>
                        <label for="min-vnum">Minimum VNUM:</label>
                        <input type="number" id="min-vnum" min="0" />
                    </div>
                    <div>
                        <label for="max-vnum">Maximum VNUM:</label>
                        <input type="number" id="max-vnum" min="0" />
                    </div>
                </div>
            </div>
            
            <div class="info-section">
                <h3>Overroom Information</h3>
                <div class="field-group">
                    <div>
                        <label for="overroom-vnum">Overroom VNUM:</label>
                        <input type="number" id="overroom-vnum" min="0" />
                    </div>
                </div>
                <label for="overroom-name">Overroom Name:</label>
                <input type="text" id="overroom-name" class="read-only" readonly />
            </div>
            
            <div class="info-section">
                <h3>Connections</h3>
                <ul id="connection-list" class="connection-list">
                    <!-- Connections will be populated here -->
                </ul>
                <div style="margin-top: 10px;">
                    <button onclick="showAddConnectionDialog()">Add Connection</button>
                </div>
            </div>
            
            <div class="info-section">
                <button class="delete-btn" onclick="deleteSelectedArea()">Delete Area</button>
            </div>
        </div>
    </div>

    <script>
        class Vector {
            constructor(x, y) {
                this.x = Number.isFinite(x) ? x : 0;
                this.y = Number.isFinite(y) ? y : 0;
            }

            add(v) {
                return new Vector(this.x + v.x, this.y + v.y);
            }

            subtract(v) {
                return new Vector(this.x - v.x, this.y - v.y);
            }

            multiply(scalar) {
                const s = Number.isFinite(scalar) ? scalar : 0;
                return new Vector(this.x * s, this.y * s);
            }

            magnitude() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            normalize() {
                const mag = this.magnitude();
                return mag === 0 ? new Vector(0, 0) : new Vector(this.x / mag, this.y / mag);
            }
        }

        // Add selection state to the global state
        const state = {
            areas: [],
            connections: [],
            dragging: null,
            panned: false,
            resizing: null,
            offset: { x: 0, y: 0 },
            initialSize: 0,
            selection: {
                active: false,
                start: { x: 0, y: 0 },
                current: { x: 0, y: 0 },
                selectedAreas: new Set(),
                selectedConnections: new Set()
            },
            draggingConnection: null,
            connectionOffset: { x: 0, y: 0 },
            panning: false,
            panStart: { x: 0, y: 0 },
            viewBox: { x: 0, y: 0, width: 5000, height: 5000 }
        };
        // Reset drag state
        state.dragging = null;
        state.resizing = null;
        state.offset = { x: 0, y: 0 };
        state.initialSize = 0;

        // Re-attach event listeners
        const svg = document.getElementById('map');
        svg.addEventListener('mousemove', handleDrag);
        svg.addEventListener('mouseup', endDrag);
        svg.addEventListener('mouseleave', endDrag);
        // Modified drag handling for group selection
        function startDrag(e, areaIndex, isResize = false) {
            e.stopPropagation();
            const svg = document.getElementById('map');
            const pt = svg.createSVGPoint();
            // const pt = {
            //     x: e.clientX,
            //     y: e.clientY
            // };
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

            if (e.shiftKey) {
                console.log("Setting selection state.");
                // Selection rectangle handling remains the same
                state.selection.active = true;
                state.selection.start = { x: svgP.x, y: svgP.y };
                state.selection.current = { x: svgP.x, y: svgP.y };
                updateSelectionRect();
            } else if (isResize) {
                state.resizing = areaIndex;
                state.initialPos = { x: state.areas[areaIndex].pos.x, y: state.areas[areaIndex].pos.y };
                state.initialSize = state.areas[areaIndex].size;
                state.dragStart = { x: svgP.x, y: svgP.y };
            } else {
                if (!state.selection.selectedAreas.has(areaIndex)) {
                    // If clicking an unselected area without shift, clear selection
                    state.selection.selectedAreas.clear();
                    state.selection.selectedConnections.clear();
                }
                state.selection.selectedAreas.add(areaIndex);
                
                state.dragging = true;
                state.offset = {
                    x: svgP.x - state.areas[areaIndex].pos.x,
                    y: svgP.y - state.areas[areaIndex].pos.y
                };
                updateMap();
            }
        }

        function handleDrag(e) {
            const svg = document.getElementById('map');
            // const point = {
            //     x: e.clientX,
            //     y: e.clientY
            // };
            const point = svg.createSVGPoint();
            const container = document.getElementById('map-container');
            point.x = e.clientX;
            point.y = e.clientY;
            const svgP = point.matrixTransform(svg.getScreenCTM().inverse());

            if (state.panning) {
                 // Calculate the delta from the start position
                const deltaX = (point.x - state.panStart.x) * (state.viewBox.width / svg.clientWidth);
                const deltaY = (point.y - state.panStart.y) * (state.viewBox.height / svg.clientHeight);
                
                // Update viewBox position based on the initial position and delta
                state.viewBox.x = state.viewBoxStart.x - deltaX;
                state.viewBox.y = state.viewBoxStart.y - deltaY;
                
                svg.setAttribute('viewBox', 
                    `${state.viewBox.x} ${state.viewBox.y} ${state.viewBox.width} ${state.viewBox.height}`
                );
                state.panned = true;
            } else if (state.draggingConnection !== null) {
                const conn = state.connections[state.draggingConnection];
                conn.rectPos = {
                    x: svgP.x - state.connectionOffset.x,
                    y: svgP.y - state.connectionOffset.y
                };
                updateMap();
            } else if (state.selection.active) {
                state.selection.current = { x: svgP.x, y: svgP.y };
                updateSelectionRect();
            } else if (state.resizing !== null) {
                const area = state.areas[state.resizing];
                const dx = svgP.x - state.dragStart.x;
                const dy = svgP.y - state.dragStart.y;
                
                // Calculate resize factor based on drag direction
                // Positive when dragging down-right, negative when dragging up-left
                const dragDistance = Math.sqrt(dx * dx + dy * dy);
                const dragDirection = Math.sign(dx + dy);
                const newSize = Math.max(30, state.initialSize + (dragDistance * dragDirection));
                
                area.size = newSize;
                updateMap();
            } else if (state.dragging) {
                const dx = svgP.x - state.offset.x - state.areas[Array.from(state.selection.selectedAreas)[0]].pos.x;
                const dy = svgP.y - state.offset.y - state.areas[Array.from(state.selection.selectedAreas)[0]].pos.y;
                
                state.selection.selectedAreas.forEach(areaIndex => {
                    const area = state.areas[areaIndex];
                    area.pos.x += dx;
                    area.pos.y += dy;
                });
                
                // Move selected rectangle connections
                state.selection.selectedConnections.forEach(connIndex => {
                    const conn = state.connections[connIndex];
                    if (conn.useRect && conn.rectPos) {
                        conn.rectPos.x += dx;
                        conn.rectPos.y += dy;
                    }
                });
                updateMap();
            }
        }

        function endDrag(e) {
            if (state.selection.active) {
                finalizeSelection();
            }
            state.dragging = null;
            state.resizing = null;
            state.selection.active = false;
            state.draggingConnection = null;
            if (state.panning) {
                svg.style.cursor = 'grab';
                if(state.panned == false)
                {
                    state.selection.selectedAreas.clear();
                    state.selection.selectedConnections.clear();
                }
            }
            state.panning = false;

            document.getElementById('selection-rect').style.display = 'none';
            updateMap();
        }

        function updateSelectionRect() {
            const rect = document.getElementById('selection-rect');
            const x = Math.min(state.selection.start.x, state.selection.current.x);
            const y = Math.min(state.selection.start.y, state.selection.current.y);
            const width = Math.abs(state.selection.current.x - state.selection.start.x);
            const height = Math.abs(state.selection.current.y - state.selection.start.y);
            
            rect.setAttribute('x', x);
            rect.setAttribute('y', y);
            rect.setAttribute('width', width);
            rect.setAttribute('height', height);
            rect.style.display = 'block';
            
        }

        function finalizeSelection() {
            const x1 = Math.min(state.selection.start.x, state.selection.current.x);
            const y1 = Math.min(state.selection.start.y, state.selection.current.y);
            const x2 = Math.max(state.selection.start.x, state.selection.current.x);
            const y2 = Math.max(state.selection.start.y, state.selection.current.y);

            state.areas.forEach((area, index) => {
                // Check if any part of the circle intersects with the selection rectangle
                const circleLeft = area.pos.x - area.size;
                const circleRight = area.pos.x + area.size;
                const circleTop = area.pos.y - area.size;
                const circleBottom = area.pos.y + area.size;

                if (!(circleRight < x1 || // circle is completely to the left
                    circleLeft > x2 || // circle is completely to the right
                    circleBottom < y1 || // circle is completely above
                    circleTop > y2)) { // circle is completely below
                    state.selection.selectedAreas.add(index);
                }
            });

            // Select rectangle connections
            state.connections.forEach((conn, index) => {
                if (conn.useRect && conn.rectPos) {
                    const rectLeft = conn.rectPos.x - 50;  // Half of rectangle width
                    const rectRight = conn.rectPos.x + 50;
                    const rectTop = conn.rectPos.y - 15;   // Half of rectangle height
                    const rectBottom = conn.rectPos.y + 15;

                    if (!(rectRight < x1 || rectLeft > x2 || rectBottom < y1 || rectTop > y2)) {
                        state.selection.selectedConnections.add(index);
                    }
                }
            });
            updateMap();
        }

        
        // Map rendering
        function updateConnections() {
            const connectionsGroup = document.getElementById('connections');
            connectionsGroup.innerHTML = '';

            state.connections.forEach((conn, index) => {
                const source = state.areas[conn.source];
                const target = state.areas[conn.target];
                
                if (!source?.pos?.x || !source?.pos?.y || !target?.pos?.x || !target?.pos?.y) {
                    console.warn('Invalid connection - missing position data:', conn);
                    return;
                }

                if (conn.useRect) {
                    // Create rectangle group
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    
                    // Draw line from source to rectangle
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    line.setAttribute("d", `M ${source.pos.x} ${source.pos.y} L ${conn.rectPos.x} ${conn.rectPos.y}`);
                    line.setAttribute("stroke", "#666");
                    line.setAttribute("stroke-width", "2");
                    line.setAttribute("fill", "none");
                    line.setAttribute("marker-end", "url(#arrowhead)");
                    g.appendChild(line);

                    // Create rectangle
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute("x", conn.rectPos.x - 50);
                    rect.setAttribute("y", conn.rectPos.y - 15);
                    rect.setAttribute("width", 100);
                    rect.setAttribute("height", 30);
                    rect.setAttribute("fill", state.selection.selectedConnections.has(index) ? "#bfdbfe" : "#fff");
                    rect.setAttribute("stroke", state.selection.selectedConnections.has(index) ? "#3b82f6" : "#666");
                    rect.setAttribute("stroke-width", "2");
                    rect.setAttribute("rx", "4");
                    rect.setAttribute("cursor", "move");
                    
                    // Add mousedown event for dragging
                    rect.onmousedown = (e) => {
                        e.stopPropagation();
                        const svg = document.getElementById('map');
                        const pt = svg.createSVGPoint();
                        pt.x = e.clientX;
                        pt.y = e.clientY;
                        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                        
                        if(!e.shiftKey && !state.selection.selectedConnections.has(index))
                            state.selection.selectedConnections.clear();
                        state.selection.selectedConnections.add(index);

                        state.draggingConnection = index;
                        state.connectionOffset = {
                            x: svgP.x - conn.rectPos.x,
                            y: svgP.y - conn.rectPos.y
                        };
                    };
                    g.appendChild(rect);

                    // Add text
                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", conn.rectPos.x);
                    text.setAttribute("y", conn.rectPos.y);
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("dominant-baseline", "middle");
                    text.setAttribute("font-family", "Arial");
                    text.setAttribute("font-size", "12px");
                    text.setAttribute("pointer-events", "none");
                    text.textContent = `To ${target.name}`;
                    g.appendChild(text);

                    connectionsGroup.appendChild(g);
                } else {
                    // Original direct line connection code
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("d", `M ${source.pos.x} ${source.pos.y} L ${target.pos.x} ${target.pos.y}`);
                    path.setAttribute("fill", "none");
                    path.setAttribute("stroke", "#666");
                    path.setAttribute("stroke-width", "2");
                    path.setAttribute("marker-end", "url(#arrowhead)");
                    connectionsGroup.appendChild(path);
                }
            });
        }
        
        // Force-directed layout
        class ForceDirectedGraph {
            constructor(areas, connections, width, height) {
                this.width = width;
                this.height = height;
                this.areas = areas;
                this.connections = connections;
            }

            applyForces() {
                const repulsionForce = 5000;
                const springForce = 0.01;
                const springLength = 200;
                const damping = 0.95;

                // Reset forces
                this.areas.forEach(area => {
                    area.force = new Vector(0, 0);
                    area.velocity = area.velocity || new Vector(0, 0);
                });

                // Apply repulsion between all areas
                for (let i = 0; i < this.areas.length; i++) {
                    for (let j = i + 1; j < this.areas.length; j++) {
                        const area1 = this.areas[i];
                        const area2 = this.areas[j];
                        const delta = new Vector(
                            area2.pos.x - area1.pos.x,
                            area2.pos.y - area1.pos.y
                        );
                        const distance = Math.max(delta.magnitude(), 1);
                        const minDistance = area1.size + area2.size + 20;

                        if (distance < minDistance) {
                            const force = delta.normalize().multiply(repulsionForce / (distance * distance));
                            area2.force = area2.force.add(force);
                            area1.force = area1.force.add(force.multiply(-1));
                        }
                    }
                }

                // Apply spring forces for connections
                this.connections.forEach(conn => {
                    const source = this.areas[conn.source];
                    const target = this.areas[conn.target];
                    const delta = new Vector(
                        target.pos.x - source.pos.x,
                        target.pos.y - source.pos.y
                    );
                    const distance = delta.magnitude();
                    const springF = delta.normalize().multiply((distance - springLength) * springForce);
                    source.force = source.force.add(springF);
                    target.force = target.force.add(springF.multiply(-1));
                });

                // Update positions
                this.areas.forEach(area => {
                    area.velocity = area.velocity.add(area.force).multiply(damping);
                    area.pos.x += area.velocity.x;
                    area.pos.y += area.velocity.y;

                    // Keep within bounds
                    area.pos.x = Math.max(area.size, Math.min(this.width - area.size, area.pos.x));
                    area.pos.y = Math.max(area.size, Math.min(this.height - area.size, area.pos.y));
                });
            }
        }

        function initializeMap(areasData) {
            const width = 5000;
            const height = 5000;
            
            // Convert areas dictionary entries to include position and visualization data
            state.areas = Object.entries(areasData.areas).map(([name, area]) => ({
                ...area,
                name,
                size: 30 + 30 * Math.max(0, Math.min(1, 1 - (100 / Object.keys(area.rooms).length))),
                pos: new Vector(
                    width/2 + (Math.random() - 0.5) * width/4,
                    height/2 + (Math.random() - 0.5) * height/4
                ),
                velocity: new Vector(0, 0),
                force: new Vector(0, 0),
                overroomvnum: area.overroomvnum || 0,
                overroomname: area.overroomname || null,
                overroomModified: false,
                credits: area.credits || '',
                minimumlevel: area.minimumlevel || 0,
                maximumlevel: area.maximumlevel || 0,
                minimumvnum: area.minimumvnum || 0,
                maximumvnum: area.maximumvnum || 0
            }));

            // Find connections based on dictionary structure
            state.connections = findDirectionalConnections(areasData.areas);

            // Set up event listeners
            const svg = document.getElementById('map');
            svg.addEventListener('mousemove', handleDrag);
            svg.addEventListener('mouseup', endDrag);
            svg.addEventListener('mouseleave', endDrag);
            
            if (!state.viewBox) {
                state.viewBox = { x: 0, y: 0, width: 5000, height: 5000 };
                svg.setAttribute('viewBox', 
                    `${state.viewBox.x} ${state.viewBox.y} ${state.viewBox.width} ${state.viewBox.height}`
                );
            }
            updateMap();
        }

        function findDirectionalConnections(areasDict) {
            const connections = [];
            const areaNames = Object.keys(areasDict);
            
            areaNames.forEach((sourceName, sourceIndex) => {
                const sourceArea = areasDict[sourceName];
                Object.entries(sourceArea.rooms).forEach(([roomId, room]) => {
                    Object.entries(room.exits).forEach(([direction, targetId]) => {
                        if (targetId) {
                            // Find which area contains the target room
                            const targetName = areaNames.find(name => 
                                Object.keys(areasDict[name].rooms).includes(targetId.toString())
                            );
                            
                            if (targetName && targetName !== sourceName) {
                                const targetIndex = areaNames.indexOf(targetName);
                                const existingConnection = connections.find(conn => 
                                    conn.source === sourceIndex && 
                                    conn.target === targetIndex
                                );

                                if (!existingConnection) {
                                    connections.push({
                                        source: sourceIndex,
                                        target: targetIndex,
                                        direction: direction,
                                        useRect: false,
                                        rectPos: null
                                    });
                                }
                            }
                        }
                    });
                });
            });

            return connections;
        }


        function resetPositions() {
            const width = 5000;
            const height = 5000;
            
            state.areas.forEach(area => {
                area.pos.x = width/2 + (Math.random() - 0.5) * width/4;
                area.pos.y = height/2 + (Math.random() - 0.5) * height/4;
                area.velocity = new Vector(0, 0);
                area.force = new Vector(0, 0);
                // Update size calculation for dictionary-based rooms
                area.size = 30 + 30 * Math.max(0, Math.min(1, 1 - (100 / Object.keys(area.rooms).length)));
            });
            
            updateMap();
        }

        function runSimulation() {
            const graph = new ForceDirectedGraph(state.areas, state.connections, 5000, 5000);
            let iteration = 0;
            
            function animate() {
                graph.applyForces();
                updateMap();
                iteration++;
                
                if (iteration < 100) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        // Function to load new data
        function loadNewData(jsonData) {
            try {
                const data = JSON.parse(jsonData);
                initializeMap(data);
            } catch (error) {
                console.error('Error parsing JSON data:', error);
            }
        }

        function saveLayout() {
            // Convert array-based state to dictionary format for saving
            const areasDict = {};
            state.areas.forEach((area) => {
                areasDict[area.name] = {
                    position: { x: area.pos.x, y: area.pos.y },
                    size: area.size,
                    overroomvnum: area.overroomvnum,
                    overroomname: area.overroomname,
                    credits: area.credits,
                    minimumlevel: area.minimumlevel,
                    maximumlevel: area.maximumlevel,
                    minimumvnum: area.minimumvnum,
                    maximumvnum: area.maximumvnum
                };
            });

            const layout = {
                areas: areasDict,
                connections: state.connections.map(conn => ({
                    sourceName: state.areas[conn.source].name,
                    targetName: state.areas[conn.target].name,
                    direction: conn.direction,
                    useRect: conn.useRect,
                    rectPos: conn.rectPos
                }))
            };

            const blob = new Blob([JSON.stringify(layout, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'map-layout.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadLayout(layoutData) {
            // Convert dictionary format back to array for internal state
            state.areas = Object.entries(layoutData.areas).map(([name, data]) => ({
                name: name,
                rooms: {},  // Maintain empty rooms object for compatibility
                pos: new Vector(data.position.x, data.position.y),
                size: data.size,
                velocity: new Vector(0, 0),
                force: new Vector(0, 0),
                overroomvnum: data.overroomvnum || 0,
                overroomname: data.overroomname || null,
                overroomModified: false,
                credits: data.credits || '',
                minimumlevel: data.minimumlevel || 0,
                maximumlevel: data.maximumlevel || 0,
                minimumvnum: data.minimumvnum || 0,
                maximumvnum: data.maximumvnum || 0
            }));

            // Create a name to index mapping for connection conversion
            const nameToIndex = {};
            state.areas.forEach((area, index) => {
                nameToIndex[area.name] = index;
            });

            // Convert connections using name to index mapping
            state.connections = layoutData.connections.map(conn => ({
                source: nameToIndex[conn.sourceName],
                target: nameToIndex[conn.targetName],
                direction: conn.direction,
                useRect: conn.useRect,
                rectPos: conn.rectPos
            }));

            state.dragging = null;
            state.resizing = null;
            state.offset = { x: 0, y: 0 };
            state.initialSize = 0;
            
            updateMap();
        }
        function triggerDownload(imgURI) {
            const a = document.createElement('a');
            a.download = 'map.png'; // filename
            a.target = '_blank';
            a.href = imgURI;

            // trigger download button
            // (set `bubbles` to false here.
            // or just `a.click()` if you don't care about bubbling)
            a.dispatchEvent(new MouseEvent('click', {
                view: window,
                bubbles: false,
                cancelable: true
            }));
        }

        const btn = document.getElementById('pngbutton');
        btn.addEventListener('click', function () {
            const svgNode = document.querySelector('svg');
            const svgString = (new XMLSerializer()).serializeToString(svgNode);
            const svgBlob = new Blob([svgString], {
                type: 'image/svg+xml;charset=utf-8'
            });
            
            const DOMURL = window.URL || window.webkitURL || window;
            const url = DOMURL.createObjectURL(svgBlob);
            const a = document.createElement('a');
            a.download = 'map.svg'; // filename
            a.target = '_blank';
            a.href = url;
            a.dispatchEvent(new MouseEvent('click', {
                view: window,
                bubbles: false,
                cancelable: true
            }));
            const image = new Image();
            image.width = svgNode.width.baseVal.value;
            image.height = svgNode.height.baseVal.value;
            image.src = url;
            image.onload = function () {
                const canvas = document.getElementById('canvas');
                canvas.width = image.width;
                canvas.height = image.height;

                const ctx = canvas.getContext('2d');
                ctx.drawImage(image, 0, 0);
                DOMURL.revokeObjectURL(url);

                const imgURI = canvas
                .toDataURL('image/png')
                .replace('image/png', 'image/octet-stream');
                triggerDownload(imgURI);
            };
        });
        function updateAreas() {
            const areasGroup = document.getElementById('areas');
            areasGroup.innerHTML = '';

            state.areas.forEach((area, index) => {
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", area.pos.x);
                circle.setAttribute("cy", area.pos.y);
                circle.setAttribute("r", area.size);
                
                // Determine circle class based on overroom status
                let circleClass = 'area-circle';
                if (area.overroomname) {
                    circleClass += ' has-overroom';
                }
                if (area.overroomModified) {
                    circleClass += ' modified-overroom';
                }
                if (state.selection.selectedAreas.has(index)) {
                    circleClass += ' selected';
                }
                
                circle.setAttribute("class", circleClass);
                circle.setAttribute("stroke", "#64748b");
                circle.setAttribute("stroke-width", "2");
                circle.onmousedown = (e) => startDrag(e, index);
                g.appendChild(circle);

                // Resize handle
                const handle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                handle.setAttribute("cx", area.pos.x + area.size * Math.cos(Math.PI / 4));
                handle.setAttribute("cy", area.pos.y + area.size * Math.sin(Math.PI / 4));
                handle.setAttribute("r", 5);
                handle.setAttribute("class", "resize-handle");
                handle.onmousedown = (e) => {
                    e.stopPropagation();
                    startDrag(e, index, true);
                };
                g.appendChild(handle);

                // Text label
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", area.pos.x);
                text.setAttribute("y", area.pos.y);
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("dominant-baseline", "middle");
                text.setAttribute("font-family", "Arial");
                text.setAttribute("font-size", `${Math.min(area.size / 4, 14)}px`);
                text.setAttribute("class", "area-text");
                text.textContent = area.name;
                g.appendChild(text);

                areasGroup.appendChild(g);
                
            });
            
        }

        function addNewArea() {
            const width = 100;
            const height = 100;
            const newArea = {
                name: "New Area",
                // Initialize with empty rooms dictionary instead of array
                rooms: {},
                pos: new Vector(
                    width/2 + (Math.random() - 0.5) * width/4,
                    height/2 + (Math.random() - 0.5) * height/4
                ),
                size: 30,
                velocity: new Vector(0, 0),
                force: new Vector(0, 0)
            };
            
            state.areas.push(newArea);
            updateMap();
        }

        function updateInfoPanel() {
            const panel = document.getElementById('info-panel');
            const nameInput = document.getElementById('area-name');
            const overroomVnumInput = document.getElementById('overroom-vnum');
            const overroomNameInput = document.getElementById('overroom-name');
            const connectionList = document.getElementById('connection-list');
            
            if (state.selection.selectedAreas.size === 1) {
                panel.style.display = 'block';
                const areaIndex = Array.from(state.selection.selectedAreas)[0];
                const area = state.areas[areaIndex];
                
                // Update name
                nameInput.value = area.name;
                nameInput.onchange = (e) => {
                    area.name = e.target.value;
                    updateMap();
                };
                
                // Update overroom information
                overroomVnumInput.value = area.overroomvnum || '';
                overroomNameInput.value = area.overroomname || '';
                
                overroomVnumInput.onchange = (e) => {
                    const newVnum = parseInt(e.target.value) || 0;
                    if (newVnum !== area.overroomvnum) {
                        area.overroomvnum = newVnum;
                        area.overroomModified = true;
                        updateMap();
                    }
                };
                document.getElementById('area-credits').value = area.credits || '';
                document.getElementById('min-level').value = area.minimumlevel || 0;
                document.getElementById('max-level').value = area.maximumlevel || 0;
                document.getElementById('min-vnum').value = area.minimumvnum || 0;
                document.getElementById('max-vnum').value = area.maximumvnum || 0;
                document.getElementById('overroom-vnum').value = area.overroomvnum || 0;
                document.getElementById('overroom-name').value = area.overroomname || '';

                document.getElementById('area-credits').onchange = (e) => {
                    area.credits = e.target.value;
                    updateMap();
                };
                
                document.getElementById('min-level').onchange = (e) => {
                    area.minimumlevel = parseInt(e.target.value) || 0;
                    updateMap();
                };
                
                document.getElementById('max-level').onchange = (e) => {
                    area.maximumlevel = parseInt(e.target.value) || 0;
                    updateMap();
                };
                
                document.getElementById('min-vnum').onchange = (e) => {
                    area.minimumvnum = parseInt(e.target.value) || 0;
                    updateMap();
                };
                
                document.getElementById('max-vnum').onchange = (e) => {
                    area.maximumvnum = parseInt(e.target.value) || 0;
                    updateMap();
                };

                // Update connections list
                connectionList.innerHTML = '';
                state.connections
                    .filter(conn => conn.source === areaIndex)
                    .forEach(conn => {
                        const li = document.createElement('li');
                        li.className = 'connection-item';
                        const reverseConn = state.connections.find(c => 
                            c.source === conn.target && c.target === conn.source
                        );
                        const textContainer = document.createElement('div');
                        textContainer.style.display = 'flex';
                        textContainer.style.flexDirection = 'column';
                        
                        const text = document.createElement('div');
                        text.style.display = 'flex';
                        text.style.alignItems = 'center';
                        text.style.gap = '4px';
                        
                        // Create source area link
                        const sourceLink = document.createElement('a');
                        sourceLink.href = '#';
                        sourceLink.textContent = state.areas[conn.source].name;
                        sourceLink.style.color = '#3b82f6';
                        sourceLink.style.textDecoration = 'none';
                        sourceLink.onclick = (e) => {
                            e.preventDefault();
                            centerOnArea(conn.source);
                        };
                        
                        // Create target area link
                        const targetLink = document.createElement('a');
                        targetLink.href = '#';
                        targetLink.textContent = state.areas[conn.target].name;
                        targetLink.style.color = '#3b82f6';
                        targetLink.style.textDecoration = 'none';
                        targetLink.onclick = (e) => {
                            e.preventDefault();
                            centerOnArea(conn.target);
                        };
                        
                        // Add arrow symbol based on connection type
                        const arrows = document.createTextNode(reverseConn ? ' ←→ ' : ' → ');
                        
                        text.appendChild(sourceLink);
                        text.appendChild(arrows);
                        text.appendChild(targetLink);
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.checked = conn.useRect;
                        checkbox.onchange = (e) => {
                            conn.useRect = e.target.checked;
                            if (conn.useRect && !conn.rectPos) {
                                conn.rectPos = {
                                    x: (state.areas[conn.source].pos.x + state.areas[conn.target].pos.x) / 2,
                                    y: (state.areas[conn.source].pos.y + state.areas[conn.target].pos.y) / 2
                                };
                            }
                            
                            if (reverseConn) {
                                reverseConn.useRect = e.target.checked;
                                if (reverseConn.useRect && !reverseConn.rectPos) {
                                    reverseConn.rectPos = {
                                        x: (state.areas[conn.source].pos.x + state.areas[conn.target].pos.x) / 2 + 30,
                                        y: (state.areas[conn.source].pos.y + state.areas[conn.target].pos.y) / 2 + 30
                                    };
                                }
                            }
                            updateMap();
                        };
                        
                        const checkboxLabel = document.createElement('label');
                        checkboxLabel.style.fontSize = '0.8em';
                        checkboxLabel.style.display = 'flex';
                        checkboxLabel.style.alignItems = 'center';
                        checkboxLabel.style.gap = '4px';
                        checkboxLabel.appendChild(checkbox);
                        checkboxLabel.appendChild(document.createTextNode('Use rectangle'));
                        
                        textContainer.appendChild(text);
                        textContainer.appendChild(checkboxLabel);
                        
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'delete-btn';
                        deleteBtn.textContent = 'Delete';
                        deleteBtn.onclick = () => deleteConnection(conn);
                        
                        li.appendChild(textContainer);
                        li.appendChild(deleteBtn);
                        connectionList.appendChild(li);
                    });
            } else {
                panel.style.display = 'none';
            }
        }

        function deleteConnection(connection) {
            const index = state.connections.findIndex(conn => 
                conn.source === connection.source && 
                conn.target === connection.target
            );
            if (index !== -1) {
                state.connections.splice(index, 1);
                updateMap();
            }
        }

        function deleteSelectedArea() {
            if (state.selection.selectedAreas.size === 1) {
                const areaIndex = Array.from(state.selection.selectedAreas)[0];
                
                // Remove all connections involving this area
                state.connections = state.connections.filter(conn => 
                    conn.source !== areaIndex && conn.target !== areaIndex
                );
                
                // Remove the area
                state.areas.splice(areaIndex, 1);
                
                // Update connection indices
                state.connections.forEach(conn => {
                    if (conn.source > areaIndex) conn.source--;
                    if (conn.target > areaIndex) conn.target--;
                });
                
                // Clear selection
                state.selection.selectedAreas.clear();
                state.selection.selectedConnections.clear();
                updateMap();
            }
        }

        function showAddConnectionDialog() {
            if (state.selection.selectedAreas.size !== 1) return;
            
            const sourceIndex = Array.from(state.selection.selectedAreas)[0];
            const select = document.getElementById('target-area-select');
            
            // Clear and populate select options
            select.innerHTML = '<option value="">Select an area</option>';
            state.areas.forEach((area, index) => {
                if (index !== sourceIndex) {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = area.name;
                    select.appendChild(option);
                }
            });
            
            // Reset checkboxes
            document.getElementById('two-way-checkbox').checked = false;
            document.getElementById('use-rect-checkbox').checked = false;
            
            // Show modal
            document.getElementById('modal-overlay').style.display = 'block';
        }

        function closeConnectionDialog() {
            document.getElementById('modal-overlay').style.display = 'none';
        }

        function addNewConnection() {
            const sourceIndex = Array.from(state.selection.selectedAreas)[0];
            const targetSelect = document.getElementById('target-area-select');
            const targetIndex = parseInt(targetSelect.value);
            const isTwoWay = document.getElementById('two-way-checkbox').checked;
            const useRect = document.getElementById('use-rect-checkbox').checked;
            
            if (!targetSelect.value) return;
            
            const sourcePos = state.areas[sourceIndex].pos;
            const targetPos = state.areas[targetIndex].pos;
            
            // Calculate midpoint for rectangle position
            const midPoint = {
                x: (sourcePos.x + targetPos.x) / 2,
                y: (sourcePos.y + targetPos.y) / 2
            };

            // Create forward connection
            const newConnection = {
                source: sourceIndex,
                target: targetIndex,
                direction: 'custom',
                useRect: useRect,
                rectPos: midPoint
            };

            // Add the connection
            state.connections.push(newConnection);

            // Create reverse connection if two-way is selected
            if (isTwoWay) {
                const reverseConnection = {
                    source: targetIndex,
                    target: sourceIndex,
                    direction: 'custom',
                    useRect: useRect,
                    rectPos: {
                        x: midPoint.x + 30,
                        y: midPoint.y + 30
                    }
                };
                state.connections.push(reverseConnection);
            }
            
            // Update map and close dialog
            updateMap();
            closeConnectionDialog();
        }
        // Modify updateMap to include info panel update
        function updateMap() {
            updateConnections();
            updateAreas();
            updateInfoPanel();
        }

        // Function to center view on an area
        function centerOnArea(areaIndex) {
            const area = state.areas[areaIndex];
            if (!area) return;
            
            const container = document.getElementById('map-container');
            const svg = document.getElementById('map');
            
            // Calculate the center position
            const svgWidth = parseInt(svg.getAttribute('width'));
            const svgHeight = parseInt(svg.getAttribute('height'));
            
            // Calculate scroll position to center the area
            const scrollX = area.pos.x - (container.clientWidth / 2);
            const scrollY = area.pos.y - (container.clientHeight / 2);
            
            // Smooth scroll to the position
            container.scrollTo({
                left: scrollX,
                top: scrollY,
                behavior: 'smooth'
            });
            
            // Select the area
            state.selection.selectedAreas.clear();
            state.selection.selectedConnections.clear();
            state.selection.selectedAreas.add(areaIndex);
            updateMap();
        }
        // Modify the initialization
        document.getElementById('dataInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        initializeMap(data);
                    } catch (error) {
                        console.error('Error parsing JSON file:', error);
                        alert('Error loading file: Please ensure it is a valid JSON file');
                    }
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('layoutInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const layoutData = JSON.parse(e.target.result);
                        loadLayout(layoutData);
                    } catch (error) {
                        console.error('Error parsing layout file:', error);
                        alert('Error loading layout: Please ensure it is a valid JSON file');
                    }
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('map').addEventListener('mousedown', function(e) {
            if (e.target === this) {
                if (e.shiftKey) {
                    startDrag(e, -1, false);
                } else {
                    state.panning = true;
                    state.panned = false;
                    state.panStart = {
                        x: e.clientX,
                        y: e.clientY
                    };
                    // Store initial viewBox position
                    state.viewBoxStart = {
                        x: state.viewBox.x,
                        y: state.viewBox.y
                    };
                    svg.style.cursor = 'grabbing';
                    
                    updateMap();
                }
            }
        });

        document.getElementById('map-container').addEventListener('wheel', function(e) {
            e.preventDefault();
            
            const svg = document.getElementById('map');
            const point = svg.createSVGPoint();
            point.x = e.clientX;
            point.y = e.clientY;
            const svgP = point.matrixTransform(svg.getScreenCTM().inverse());
            
            const ZOOM_SPEED = 0.1;
            const MIN_ZOOM = 0.1;
            const MAX_ZOOM = 5;
            
            // Calculate zoom direction and factor
            const direction = e.deltaY > 0 ? 1 : -1;
            const factor = (1 + direction * ZOOM_SPEED);
            const newZoom = (state.viewBox.width / 5000) * factor; // 5000 is original width
            
            // Check zoom bounds
            if (newZoom < MIN_ZOOM || newZoom > MAX_ZOOM) return;
            
            // Calculate new dimensions
            const newWidth = 5000 * newZoom;
            const newHeight = 5000 * newZoom;
            
            // Calculate mouse position relative to viewBox
            const mouseX = (svgP.x - state.viewBox.x) / state.viewBox.width;
            const mouseY = (svgP.y - state.viewBox.y) / state.viewBox.height;
            
            // Calculate new position to maintain mouse point
            const dx = (newWidth - state.viewBox.width) * mouseX;
            const dy = (newHeight - state.viewBox.height) * mouseY;
            
            state.viewBox.x -= dx;
            state.viewBox.y -= dy;
            state.viewBox.width = newWidth;
            state.viewBox.height = newHeight;
            
            // Update viewBox
            svg.setAttribute('viewBox', 
                `${state.viewBox.x} ${state.viewBox.y} ${state.viewBox.width} ${state.viewBox.height}`
            );
        });
// Add zoom control buttons to the controls div
        // const controlsDiv = document.querySelector('.controls');
        // const zoomControls = document.createElement('div');
        // zoomControls.className = 'control-group';
        // zoomControls.innerHTML = `
        //     <button onclick="zoomIn()">+</button>
        //     <div class="zoom-level">100%</div>
        //     <button onclick="zoomOut()">-</button>
        //     <button onclick="resetZoom()">↺</button>
        // `;
        // controlsDiv.appendChild(zoomControls);

        // Add these zoom control functions
        function zoomIn() {
            const factor = 0.9; // Zoom in by reducing viewBox
            updateZoom(factor);
        }

        function zoomOut() {
            const factor = 1.1; // Zoom out by increasing viewBox
            updateZoom(factor);
        }

        function resetZoom() {
            state.viewBox = { x: 0, y: 0, width: 5000, height: 5000 };
            updateViewBox();
        }

        function updateZoom(factor) {
            const MIN_ZOOM = 0.1;
            const MAX_ZOOM = 5;
            const newZoom = (state.viewBox.width / 5000) * factor;
            
            if (newZoom < MIN_ZOOM || newZoom > MAX_ZOOM) return;
            
            // Calculate center point of current view
            const centerX = state.viewBox.x + state.viewBox.width / 2;
            const centerY = state.viewBox.y + state.viewBox.height / 2;
            
            // Calculate new dimensions
            const newWidth = state.viewBox.width * factor;
            const newHeight = state.viewBox.height * factor;
            
            // Calculate new position to maintain center point
            state.viewBox.x = centerX - newWidth / 2;
            state.viewBox.y = centerY - newHeight / 2;
            state.viewBox.width = newWidth;
            state.viewBox.height = newHeight;
            
            updateViewBox();
        }

        function updateViewBox() {
            const svg = document.getElementById('map');
            svg.setAttribute('viewBox', 
                `${state.viewBox.x} ${state.viewBox.y} ${state.viewBox.width} ${state.viewBox.height}`
            );
            
            // Update zoom level display
            const zoomLevel = Math.round((5000 / state.viewBox.width) * 100);
            document.querySelector('.zoom-level').textContent = `${zoomLevel}%`;
        }
    </script>

    <div id="modal-overlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div id="modal-content" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; width: 400px;">
            <h2 style="margin-bottom: 20px; font-size: 1.5em;">Add New Connection</h2>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px;">Connect to Area:</label>
                <select id="target-area-select" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                    <option value="">Select an area</option>
                </select>
            </div>

            <div style="margin-bottom: 16px;">
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="two-way-checkbox">
                    Two-way connection
                </label>
            </div>

            <div style="margin-bottom: 24px;">
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="use-rect-checkbox">
                    Use rectangle for connection(s)
                </label>
            </div>

            <div style="display: flex; justify-content: flex-end; gap: 8px;">
                <button onclick="closeConnectionDialog()" style="padding: 8px 16px; border: 1px solid #ccc; border-radius: 4px; background: white; color: red;">Cancel</button>
                <button onclick="addNewConnection()" style="padding: 8px 16px; border-radius: 4px; background: #3b82f6; color: white; border: none;">Add Connection</button>
            </div>
        </div>
    </div>
</body>
</html>